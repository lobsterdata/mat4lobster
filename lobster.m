classdef lobster
    % lobster imports data from data, such as limit order book, message and
    % limit order data, generated by LOBSTER. It also provide some useful
    % functions to examine the data roughly.
    %
    % $Author: frischedaten UG$  $Date: 2015/11/11 $ $Revision: 0.1$
    methods(Static)
        function data = readBinOrderBook(filename,level)
            %lobster.readBinOrderBook reads order book data in binary
            %format.
            %
            %data = lobster.readBinOrderBook(filename, l) returns the order
            %  book data (l levels) readed from filename.
            %
            %See also Lobster.readCSVOrderBook, Lobster.readOrderBook
            fid=fopen(filename);
            data= fread(fid,inf,'int64',0,'b');
            fclose(fid);
            data=reshape(data,level*4,[]);
            data=data';
        end
        
        function data = readCSVOrderBook(filename)
            %lobster.readBinOrderBook reads order book data in CSV format.
            %
            %data = lobster.readCSVOrderBook(filename) returns the order
            %  book data readed from filename.
            %
            %See also Lobster.readBinOrderBook, Lobster.readOrderBook
            data= load(filename,'-ascii');
        end
        
        function data = readOrderBook(filename,format,level)
            %lobster.readOrderBook reads order book data.
            %
            %data = lobster.readOrderBook(filename) returns the order
            %  book data readed from filename which in CSV format.
            %
            %data = lobster.readOrderBook(filename,format,l) returns the
            %order
            %  book data readed from filename which can be either binary or
            %  CSV format. It it is binary format the level of order book,
            %  l, must be specified.  The value of format can be 'csv' or
            %  'bin'.
            %
            %See also Lobster.readBinOrderBook, Lobster.readCSVOrderBook
            if nargin<2
                format='CSV';
            end
            if strcmpi(format,'bin') && nargin<3
                error('Level must be set for binary data!')
            end
            switch lower(format)
                case {'csv'}
                    data = lobster.readCSVOrderBook(filename);
                case {'bin'}
                    data = lobster.readBinOrderBook(filename,level);
            end
        end
        
        function data = readBinMessage(filename)
            %lobster.readBinMessage reads message data from a file
            % in binary format.
            %
            %data = lobster.readMessage(filename) returns the message data
            %   readed from filename which in CSV format.
            %
            %data = lobster.readOrderBook(filename,format) returns the
            %message
            %  data readed from filename which can be either binary or CSV
            %  format. The value of format can be 'csv' or 'bin'
            %
            %See also lobster.readCSVMessage, lobster.readMessage
            fid=fopen(filename);
            rawdata= fread(fid,inf,'int64',0,'b');
            fclose(fid);
            rawdata=reshape(rawdata,7,[]);
            rawdata=rawdata';
            data=[rawdata(:,1)+1.0*rawdata(:,2)/10^9,rawdata(:,3:end)];
        end
        
        function data = readCSVMessage(filename)
            %lobster.readCSVMessage reads message data from a file in CSV
            % format.
            %
            %data = lobster.readMessage(filename) returns the message data
            %   readed from filename which in CSV format.
            %
            %
            %See also lobster.readBinMessage, lobster.readMessage
            data= load(filename,'-ascii');
        end
        
        function data = readMessage(filename,format)
            %lobster.readMessage reads message data generated by LOBSTER.
            %
            %data = lobster.readMessage(filename) returns the message data
            %   readed from filename which in CSV format.
            %
            %data = lobster.readOrderBook(filename,format) returns the
            %message
            %  data readed from filename which can be either binary or CSV
            %  format. The value of format can be 'csv' or 'bin'
            %
            %See also lobster.readBinMessage, lobster.readCSVMessage
            if nargin<2
                format='CSV';
            end
            switch lower(format)
                case {'csv'}
                    data = lobster.readCSVMessage(filename);
                case {'bin'}
                    data = lobster.readBinMessage(filename);
            end
        end
        
        function [idx,newTimeStamp] = getRegularIntervalIndices(timeStamp,...
                interval, startTime, endTime)
            % lobster.getRegularIntervalIndices compute the indices of the
            % irregular time stamp which corresponds a last time stamp
            % previous to the specified time stamp with a regular interval.
            % INPUT:
            %
            %       timeStamp -- the irregular time stamps. Typically it is
            %       the first column in message data
            %
            %       interval -- the interval in seconds. startTime -- the
            %
            %       start time of the period. The default is 9:30.
            %
            %       endTime -- the end time of the period. The default is
            %       16:00.
            %
            % OUTPUT:
            %
            %       idx -- the corresponding last indices of $timeStamp$
            %       that immediately before the reguaral time point.
            %
            %       newTimeStamp -- the regular time stamp.
            %
            % Details:
            %
            %       The output will satisfy the conditions
            %         timeStamp(idx) <= newTimeStamp, and timeStamp(idx)  >
            %         newTimeStamp
            %
            if nargin < 2
                error('Need at least two arguments: time stamp and interval.');
            end
            if nargin < 3
                startTime = 9.5*3600;
            end
            if nargin < 4
                endTime = 16*3600;
            end
            newTimeStamp = (startTime:interval:endTime)';
            if isempty(newTimeStamp)
                error('Interval to big! Check your setting on time interval!');
            end
            idx = findPreceding(newTimeStamp,timeStamp);
        end
        
        function data = message2orderflow(message,tim)
            % lobster.message2orderflow constructs the order flow data from
            % LOBSTER message data
            %
            % orderflow = message2orderflow(message,tim) returns the order
            % flow which is construct from the message data with threshold
            % time interval tim.
            %
            % This function combines the execution of limit orders at the
            % same side of market that take place less than $tim$ seconds
            % to the previous execution a into a market order. If there is
            % a new submission limit order following the execution sequence
            % from the opposite side of the market in less than $tim$
            % seconds, it will also aggregated into the market order
            % resulting in a marketable limit order in the order flow. Note
            % that the other limit order submissions are not affected by
            % this function
            %
            % FIELDS OF OUTPUT:
            %
            %  (1) time stamp.
            %
            %  (2) marketable or not. 1 indicates it is a marketable order.
            %                         0 indicates a standing limit order
            %
            %  (3) qunatity. The quantity of the order
            %
            %  (4) price. The limit price of the order. In case of
            %  market(able) order, it is the last price in the limit order
            %  execution sequence.
            %
            %  (5) trading direction. 1 is a buy market/limit order. -1 is
            %  a sell market/limit order.
            %  
            %
            %  (6) hidden price. >0 for marketable orders that filled
            %  partially by hidden orders.
            %
            %  (7) trade price. The volume weighted prices of entile
            %  trading. >0 for marketable orders.
            %
            %  (8) trade quantity. >O for market(able) orders. Note that
            %  the trade quantity of marketable orders is different from
            %  its order quantity in case it is NOT totally filled
            %
            %See also lobster.message2trades
            myms = message(message(:,2)==1 | message(:,2)>3,:);
            data =[];
            if ~isempty(myms)
                myfl = toOrderFlow(myms',tim);
                myfl=myfl';
                data = myfl(myfl(:,1)~=0,:);
            else
                warning(1,...
                    'No order submission and execution found! Return empty matrix!')
            end
        end
        
        function data = message2trades(message,tim)
            %lobster.message2trades constructs the trades data from LOBSTER
            % message data
            %
            % tradeData = message2trades(message,tim)
            %
            % returns the trade data which is constructed from the message
            % data with threshold time interval tim.
            %
            % This function combines the execution of limit orders at the
            % same side of market in a time interval less than $tim$
            % seconds to a trade.
            %
            % FIELDS OF OUTPUT:
            %
            % (1) time stamp.
            %
            % (2) price. The last price in the trade.
            %
            % (3) trading direction. 1 is a buy order. -1 is a sell order.
            %
            % (4) VWAP trade price. The volume weighted prices of entitle
            % trading.
            %
            % (5) trade quantity.
            %
            %See also lobster.message2orderflow
            myms = message(message(:,2)>3,:);
            data =[];
            if ~isempty(myms)
                myfl = toOrderFlow(myms',tim);
                myfl=myfl';
                data = myfl(myfl(:,1)~=0,[1,4,5,7,8]);
            else
                warning(1,...
                    'No order submission and execution found! Return empty matrix!')
            end
        end
        
        function plotOrderBook(orderbook)
            %lobster.plotOrderBook visualizes the order book
            %
            % Left plot: the prices and depths of order book
            %
            % Right plot: the cummulative depth (up to the prices) of the
            % order book
            lvl = floor(length(orderbook)/4);
            askPricePos = 1:4:(lvl*4);
            askVolPos   = askPricePos+1;
            bidPricePos = askPricePos+2;
            bidVolPos   = bidPricePos+1;
            vol         = 2:2:(lvl*4);
            maxPrice =  orderbook(askPricePos(lvl)) + 0.01;
            minPrice =  orderbook(bidPricePos(lvl)) - 0.01;
            maxVol =  max(orderbook(vol));
            
            subplot(1,2,1)
            barh(orderbook(askPricePos)', ...
                orderbook(askVolPos)','green');
            hold on
            barh(orderbook(bidPricePos)', ...
                orderbook(bidVolPos)','red');
            xlabel('Volume');
            ylabel('Price');
            ylim([minPrice,maxPrice]);
            xlim([0,maxVol]);
            hold off
            subplot(1,2,2)
            
            bookVolAsk = cumsum(orderbook(askVolPos));
            bookVolBid = cumsum(orderbook(bidVolPos));
            
            bookVolAsk = bookVolAsk./bookVolAsk(end);
            bookVolBid = bookVolBid./bookVolBid(end);
            
            stairs((1:lvl)',bookVolAsk','LineWidth',1.5,'Color','g');
            hold on
            stairs((1:lvl)',-1*bookVolBid','LineWidth',1.5,'Color','r');
            ylabel('% of Depth');
            xlabel('Level');
            xlim([0,lvl]);
            set(gca,'YTickLabel', ...
                {'1','0,8','0.6','0,4','0,2','','0,2', ...
                '0,4','0,6','0,8','1'},'YTick', ...
                [-1 -0.8 -0.6 -0.4 -0.2 0 0.2 0.4 0.6 0.8 1]);
            legend('Ask','Bid','Location','SouthWest');
            hold off
        end
        
        function str = timeStr(timestamp)
            % lobster.timeStr converts the Lobster time stamp to string
            % format.
            hours = floor(timestamp/3600);
            minutes = floor((timestamp - 3600*hours)/60);
            seconds = timestamp - hours*3600 - minutes*60;
            str=[int2str(hours),':',int2str(minutes),':',num2str(seconds)];
        end
    end
end
